Thinking doesn't guarantee that we won't make mistakes. But not thinking guarantees that we will.
  - Leslie Lamport, computer scientist and mathematician

BitSNARK is a protocol that is meant to handle a lot of money, so the stakes are definitely high. We need to convince our audience, as well as ourselves, of the protocol's correctness. That's a big need. In addition, while the requirements of the system are extremely simple, the implementation is highly complex, so getting the specifications right is a delicate job. Formalizing the specification properly is another big need. And distributed systems are not only notoriously hard to design, they are also hard to conceptualize and think about, as is byzantine fault tolerance, which is a fundamental domain of this entire ecosystem. And developers really need a good grasp of the system they are working on if you want them to do a good job.

Fortunately, Leslie Lamport, one of the people who birthed the very concept of distributed systems, and who developed a few of the most useful and common distributed algorithms (his name appeared in our code more than 200 times the last time I counted, mostly because he was also a leading pioneer of digital signatures and invented one of the simplest, cleverest, most robust, and earliest digital signatures), came up with a solution that satisfies all those needs. It's called TLA+, and it's a formal language for writing specifications. It defines *what* a system does, not *how* it does it. It prevents us from getting sidetracked by implementation details and forces us to focus on the correctness of the system's behavior. And it comes with a model checker that can analyze all the possible states, steps and behaviors of the specified system and verify that correctness. Sounds awesome, right? Well, it is.

But there's also some bad news. Or at least scary ones. TLA+ uses the language of science to describe all those states and steps and behaviors, and that language is math. TLA+ uses logical operators from first-order logic, set theory notation, and a bit of temporal logic in order to reason about state transition over time. In short, the specification looks like a math textbook. In this blog post I will try to bridge the gap between the intimidating notation and what it allows us to do.

Dramatis Personae

Let's dive straight into the [spec](github):

------------------------------ MODULE BitSnark ------------------------------
(***************************************************************************)
(* This module specifies the transaction flow in the BitSNARK protocol.    *)
(***************************************************************************)

EXTENDS Naturals

VARIABLES
    (* All published transactions. *)
    blockchain,
    (* Balances of the participants. *)
    balances

So, what do we have here? We start with some boilerplate, defining a module named BitSnark and adding a brief comment, we extend the Naturals module, because we will want to use natural numbers (0, 1, 2...) to describe balances, and then we jump right into defining our variables. TLA+ specifies systems as state machines, and these two variables - blockchain and balances - make up our entire state.

Transactions == {
    "Proof", "Uncontested Proof", "Challenge", "Uncontested Challenge",
    "State", "Uncontested State", "Select", "Uncontested Select",
    "Argument", "Uncontested Argument", "Proof Refuted"
}

The next bit describes the Transactions set, which contains all the different transactions that can appear in our blockchain, or at least the ones we care about.

StartingBalances == [prover |-> 2, verifier |-> 1, locked |-> 0]

This is the initial list of balances in the system. We give the prover 2 and the verifier 1 because the prover's stake should be larger than the verifier's payment, and zero for the amount initally locked inside the protocol while it's pending resolution.

IsProofValid == CHOOSE v \in {TRUE, FALSE} : TRUE

Technically, this just means that IsProofValid is always chosen between the stated values, TRUE and FALSE, and we do not specify which one. But wait, isn't this another variable? Well, not quite. Even though it has two optional values, and the model checker will certainly have to check both options, this isn't something our system can change. It's a constant throughout the execution, and nothing that our system does can turn a valid proof into a fraudulent one or vice versa.

Safety and Liveness

A correct behavior needs to satisfy two kinds of properties, often divided into safety properties and liveness properties. Safety defines what a system can do, while liveness defines what is must do, 

A common definition is that safety is making sure that bad things don't happen.




(* Invariants. *)

TypeOK ==
    /\ blockchain \subseteq Transactions
    /\ DOMAIN balances = {"prover", "verifier", "locked"}

Sum(bs) == bs["prover"] + bs["verifier"] + bs["locked"]
ValueOK == Sum(balances) = Sum(StartingBalances)

IncentiveOK ==
    /\ "Proof Refuted" \in blockchain =>
       balances["verifier"] >= StartingBalances["verifier"]
    /\ "Uncontested Argument" \in blockchain =>
       balances["prover"] >= StartingBalances["prover"]

AllOK ==
    /\ TypeOK
    /\ ValueOK
    /\ IncentiveOK

(* Transaction Functions. *)

Proof ==
    /\ blockchain = {}
    /\ blockchain' = blockchain \union {"Proof"}
    /\ balances' = [balances EXCEPT !["prover"] = @ - 2, !["locked"] = @ + 2]

UncontestedProof ==
    /\ "Proof" \in blockchain
    /\ {"Uncontested Proof", "Challenge", "State"} \intersect blockchain = {}
    /\ blockchain' = blockchain \union {"Uncontested Proof"}
    /\ balances' = [balances EXCEPT !["locked"] = @ - 2, !["prover"] = @ + 2]

Challenge ==
    /\ "Proof" \in blockchain
    /\ {"Uncontested Proof", "Challenge", "State"} \intersect blockchain = {}
    /\ blockchain' = blockchain \union {"Challenge"}
    /\ balances' = [balances EXCEPT !["verifier"] = @ - 1, !["locked"] = @ + 1]

UncontestedChallenge ==
    /\ "Challenge" \in blockchain
    /\ {"State", "Uncontested Challenge"} \intersect blockchain = {}
    /\ blockchain' = blockchain \union {"Uncontested Challenge"}
    /\ balances' = [balances EXCEPT !["locked"] = @ - 3, !["verifier"] = @ + 3]

State ==
    /\ "Proof" \in blockchain
    /\ {"Uncontested Proof", "Challenge", "State"} \intersect blockchain = {}
    /\ blockchain' = blockchain \union {"State"}
    /\ UNCHANGED balances

UncontestedState ==
    /\ "State" \in blockchain
    /\ {"Select", "Uncontested State"} \intersect blockchain = {}
    /\ blockchain' = blockchain \union {"Uncontested State"}
    /\ balances' = [balances EXCEPT !["locked"] = @ - 3, !["prover"] = @ + 3]

Select ==
    /\ "State" \in blockchain
    /\ {"Uncontested State", "Select"} \intersect blockchain = {}
    /\ blockchain' = blockchain \union {"Select"}
    /\ UNCHANGED balances

UncontestedSelect ==
    /\ "Select" \in blockchain
    /\ {"Argument", "Uncontested Select"} \intersect blockchain = {}
    /\ blockchain' = blockchain \union {"Uncontested Select"}
    /\ balances' = [balances EXCEPT !["locked"] = @ - 3, !["verifier"] = @ + 3]

Argument ==
    /\ "Select" \in blockchain
    /\ {"Uncontested Select", "Argument"} \intersect blockchain = {}
    /\ blockchain' = blockchain \union {"Argument"}
    /\ UNCHANGED balances

UncontestedArgument ==
    /\ "Argument" \in blockchain
    /\ {"Uncontested Argument", "Proof Refuted"} \intersect blockchain = {}
    /\ blockchain' = blockchain \union {"Uncontested Argument"}
    /\ balances' = [balances EXCEPT !["locked"] = @ - 3, !["prover"] = @ + 3]

ProofRefuted ==
    /\ "Argument" \in blockchain
    /\ {"Uncontested Argument", "Proof Refuted"} \intersect blockchain = {}
    /\ IsProofValid = FALSE
    /\ blockchain' = blockchain \union {"Proof Refuted"}
    /\ balances' = [balances EXCEPT !["locked"] = @ - 3, !["verifier"] = @ + 3]

(* Flow. *)

Init ==
    /\ blockchain = {}
    /\ balances = StartingBalances

Next ==
  \/ Proof
  \/ UncontestedProof
  \/ Challenge
  \/ UncontestedChallenge
  \/ State
  \/ UncontestedState
  \/ Select
  \/ UncontestedSelect
  \/ Argument
  \/ UncontestedArgument
  \/ ProofRefuted

 ============================================================================
